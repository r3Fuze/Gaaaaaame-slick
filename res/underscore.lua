local Underscore={funcs={}}Underscore.__index=Underscore;function Underscore.__call(a,value)return Underscore:new(value)end;function Underscore:new(value,chained)return setmetatable({_val=value,chained=chained or false},self)end;function Underscore.iter(b)if type(b)=='function'then return b end;return coroutine.wrap(function()for c=1,#b do coroutine.yield(b[c])end end)end;function Underscore.range(d,e,f)if e==nil then e=d;d=1 end;f=f or 1;local g=coroutine.wrap(function()for c=d,e,f do coroutine.yield(c)end end)return Underscore:new(g)end;function Underscore.identity(value)return value end;function Underscore:chain()self.chained=true;return self end;function Underscore:value()return self._val end;function Underscore.funcs.each(h,i)for c in Underscore.iter(h)do i(c)end;return h end;function Underscore.funcs.map(h,i)local j={}for c in Underscore.iter(h)do j[#j+1]=i(c)end;return j end;function Underscore.funcs.reduce(h,k,i)for c in Underscore.iter(h)do k=i(k,c)end;return k end;function Underscore.funcs.detect(h,i)for c in Underscore.iter(h)do if i(c)then return c end end;return nil end;function Underscore.funcs.select(h,i)local l={}for c in Underscore.iter(h)do if i(c)then l[#l+1]=c end end;return l end;function Underscore.funcs.reject(h,i)local l={}for c in Underscore.iter(h)do if not i(c)then l[#l+1]=c end end;return l end;function Underscore.funcs.all(h,i)i=i or Underscore.identity;for c in Underscore.iter(h)do if not i(c)then return false end end;return true end;function Underscore.funcs.any(h,i)i=i or Underscore.identity;for c in Underscore.iter(h)do if i(c)then return true end end;return false end;function Underscore.funcs.include(h,value)for c in Underscore.iter(h)do if c==value then return true end end;return false end;function Underscore.funcs.invoke(h,m,...)local n={...}Underscore.funcs.each(h,function(c)c[m](c,unpack(n))end)return h end;function Underscore.funcs.pluck(h,o)return Underscore.funcs.map(h,function(c)return c[o]end)end;function Underscore.funcs.min(h,i)i=i or Underscore.identity;return Underscore.funcs.reduce(h,{item=nil,value=nil},function(min,item)if min.item==nil then min.item=item;min.value=i(item)else local value=i(item)if value<min.value then min.item=item;min.value=value end end;return min end).item end;function Underscore.funcs.max(h,i)i=i or Underscore.identity;return Underscore.funcs.reduce(h,{item=nil,value=nil},function(max,item)if max.item==nil then max.item=item;max.value=i(item)else local value=i(item)if value>max.value then max.item=item;max.value=value end end;return max end).item end;function Underscore.funcs.to_array(h)local p={}for c in Underscore.iter(h)do p[#p+1]=c end;return p end;function Underscore.funcs.reverse(h)local q={}for c in Underscore.iter(h)do table.insert(q,1,c)end;return q end;function Underscore.funcs.sort(iter,r)local p=iter;if type(iter)=='function'then p=Underscore.funcs.to_array(iter)end;table.sort(p,r)return p end;function Underscore.funcs.first(p,s)if s==nil then return p[1]else local first={}s=math.min(s,#p)for c=1,s do first[c]=p[c]end;return first end end;function Underscore.funcs.rest(p,t)t=t or 2;local rest={}for c=t,#p do rest[#rest+1]=p[c]end;return rest end;function Underscore.funcs.slice(p,u,v)local w={}u=math.max(u,1)local x=math.min(u+v-1,#p)for c=u,x do w[#w+1]=p[c]end;return w end;function Underscore.funcs.flatten(p)local all={}for y in Underscore.iter(p)do if type(y)=='table'then local z=Underscore.funcs.flatten(y)Underscore.funcs.each(z,function(A)all[#all+1]=A end)else all[#all+1]=y end end;return all end;function Underscore.funcs.push(p,item)table.insert(p,item)return p end;function Underscore.funcs.pop(p)return table.remove(p)end;function Underscore.funcs.shift(p)return table.remove(p,1)end;function Underscore.funcs.unshift(p,item)table.insert(p,1,item)return p end;function Underscore.funcs.join(p,B)return table.concat(p,B)end;function Underscore.funcs.keys(C)local keys={}for D,E in pairs(C)do keys[#keys+1]=D end;return keys end;function Underscore.funcs.values(C)local values={}for D,E in pairs(C)do values[#values+1]=E end;return values end;function Underscore.funcs.extend(F,G)for D,E in pairs(G)do F[D]=E end;return F end;function Underscore.funcs.is_empty(C)return next(C)==nil end;function Underscore.funcs.is_equal(H,I,J)local K=type(H)local L=type(I)if K~=L then return false end;if K~='table'then return H==I end;local M=getmetatable(H)if not J and M and M.__eq then return H==I end;local is_equal=Underscore.funcs.is_equal;for N,O in pairs(H)do local P=I[N]if P==nil or not is_equal(O,P,J)then return false end end;for Q,P in pairs(I)do local O=H[Q]if O==nil then return false end end;return true end;function Underscore.funcs.compose(...)local function R(funcs,...)if#funcs>1 then return funcs[1](R(a.rest(funcs),...))else return funcs[1](...)end end;local funcs={...}return function(...)return R(funcs,...)end end;function Underscore.funcs.wrap(i,S)return function(...)return S(i,...)end end;function Underscore.funcs.curry(i,T)return function(...)return i(T,...)end end;function Underscore.functions()return Underscore.keys(Underscore.funcs)end;Underscore.methods=Underscore.functions;Underscore.funcs.for_each=Underscore.funcs.each;Underscore.funcs.collect=Underscore.funcs.map;Underscore.funcs.inject=Underscore.funcs.reduce;Underscore.funcs.foldl=Underscore.funcs.reduce;Underscore.funcs.filter=Underscore.funcs.select;Underscore.funcs.every=Underscore.funcs.all;Underscore.funcs.some=Underscore.funcs.any;Underscore.funcs.head=Underscore.funcs.first;Underscore.funcs.tail=Underscore.funcs.rest;local function U()local function V(W)local chained=false;if getmetatable(W)==Underscore then chained=W.chained;W=W._val end;return W,chained end;local function X(value,chained)if chained then value=Underscore:new(value,true)end;return value end;for Y,i in pairs(Underscore.funcs)do Underscore[Y]=function(Z,...)local C,chained=V(Z)return X(i(C,...),chained)end end end;U()return Underscore:new()